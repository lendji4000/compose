<?php

/**
 * EiBlock
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    kalifastRobot
 * @subpackage model
 * @author     Your name here
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class EiBlock extends BaseEiBlock implements ITestSetBlockParamGenerator {

    private $insertAfter = null;
    
    public $blockParameters = array();

    /**
     * Permet de déterminer, au moment de la sauvegarde, après quel block
     * on insère celui-ci.
     * @param type $insert
     */
    public function setInsertAfter($insert) {
        $this->insertAfter = $insert;
    }

    public function addEiBlockParam(EiBlockParam $param) {
        $this->blockParameters[] = $param;
    }

    /**
     * @return EiBlockParam[]
     */
    public function getParams(){
        $children = $this->getEiVersionStructures();
        $params = array();

        foreach( $children as $child ){
            if( $child instanceof EiBlockParam ){
                $params[] = $child;
            }
        }

        return $params;
    }

    /**
     * Retourne la liste des paramètres d'un block.
     *
     * @return EiBlockParam[]
     */
    public function getParamsWithQuery(){
        $params = $this->getTable()->getEiBlocksParams($this->getId());

        $this->setEiVersionStructures($params);

        return $this->getParams();
    }
    
    private function getEiBlockParamsWithQuery(){
        return Doctrine_Core::getTable('EiBlockParam')
                ->findByEiVersionStructureParentId($this->getId());
    }
    
    public function getEiBlocksWithQuery(){
        return Doctrine_Core::getTable('EiBlock')
                ->findByEiVersionStructureParentId($this->getId());
    }
    
    /**
     * Récupère les paramètres et block du block courant pour en générer le XSD.
     * L'appelle à cette méthode se fait récursivement pour chacun des blocks.
     * 
     * @param type $xsd
     * @param type $container L'élément dans lequel insérer ceux générés par la méthode.
     * @return type
     */
    public function generateXSD($xsd, $container = null){

        $element = $this->generateXSDElement($xsd);
        $insertIn = $element->firstChild->firstChild;
        
        foreach($this->getEiBlockParamsWithQuery() as $p){
            $param = $p->generateXSD($xsd);
            $insertIn->appendChild($param);
        }
        
        $sequence = $xsd->createElement("xs:sequence");
        
        $sequence->setAttribute('minOccurs', 0);
        $sequence->setAttribute('maxOccurs', "unbounded");
        
        foreach($this->getEiBlocksWithQuery() as $b){
            $block = $b->generateXSD($xsd, $element);
            $sequence->appendChild($block);
        }
        $insertIn->appendChild($sequence);
        if($container)
            $container->appendChild($element);
        else
            $xsd->appendChild($element);
                
        return $element;
    }

    /**
     * Méthode permettant de générer l'arbre des blocks & paramètres à partir des paramètres loggués.
     *
     * @param $block    Nom du block courant.
     * @param $tree     Arbre des paramètres.
     * @param $params   Liste des paramètres loggués.
     * @return mixed
     */
    public function generateTree($block, $tree, &$params)
    {
        $container = array();

        // Si l'index n'existe pas pour le block, on le crée.
        if( !isset($tree[$block]) ){
            $tree[$block] = array();
            $tree[$block]["params"] = array();
            $tree[$block]["logs"] = array();
        }

        // On ajoute les paramètres.
        foreach($this->getEiBlockParamsWithQuery() as $p){
            $container = $p->generateTree($container, $this, $params);
            $tree[$block]["params"] = $container["childs"];
            $tree[$block]["logs"] = $container["logs"];
        }

        // Puis on génère les sous-blocks.
        /** @var EiBlock $b */
        foreach($this->getEiBlocksWithQuery() as $b){
            $tree[$block] = $b->generateTree($b->getName(), $tree[$block], $params);
        }

        return $tree;
    }

    /**
     * Méthode permettant de générer le XML représentant la structure des blocks & paramètres ainsi que leurs valeurs.
     *
     * @param $tree
     * @param DomDocument $dom
     * @param null $xml
     */
    public static function generateParamsXml($tree, $dom = null, $xml = null)
    {
        // On parcourt chaque élément de l'arbre.
        foreach( $tree as $name => $branch )
        {
            // Nous récupérons les paramètres et les logs de chaque branche.
            $params = $branch["params"];
            $logs = $branch["logs"];

            // On retire ces deux index du tableau afin d'explorer les sous-blocks.
            array_splice($branch, array_search("params",array_keys($branch)), 1);
            array_splice($branch, array_search("logs",array_keys($branch)), 1);

            // S'il y a des logs, on inspecte la redondance et on crée la structure la représentant.
            if( is_array($logs) && count($logs) >= 1 ){

                // On parcourt toutes les logs qui ont été générées (cela dénote les boucles sur les blocks).
                foreach( $logs as $log ){
                    // On crée l'élément.
                    $node = $xml->appendChild($dom->createElement($name));

                    // Et pour chaque paramètre du block, on va créer les sous-éléments.
                    foreach($params as $param)
                    {
                        // Si le paramètre comprend une trace pour la log analysée, on crée et enrichit l'élément.
                        if( isset($param["datas"][$log]) ){
                            // Création de l'élément au nom du paramètre.
                            $p = $dom->createElement($param["datas"][$log]["name"]);
                            // Création de sa valeur.
                            $p->appendChild($dom->createTextNode($param["datas"][$log]["value"]));

                            // Ajout de l'attribut indiquant s'il s'agit d'un paramètre IN ou OUT.
                            $type = $dom->createAttribute("type");
                            $type->value = strtolower($param["datas"][$log]["type"]);
                            $p->appendChild($type);

                            $node->appendChild($p);
                        }
                        // Sinon, on crée un élément vide.
                        elseif( $param["datas"] == null ){
                            $p = $dom->createElement($param["name"]);
                            $node->appendChild($p);
                        }
                    }
                }
            }
            // Sinon on ajoute un élément vide.
            else{
                $node = $xml->appendChild($dom->createElement($name));
            }

            // On parcourt tous les sous-blocks afin de réaliser la même analyse et d'avancer en profondeur.
            foreach( $branch as $ind => $leaf ){
                self::generateParamsXml(array_slice($branch, array_search($ind,array_keys($branch)), 1), $dom, $node);
            }
        }
    }
    
    /**
     * Génère les balises du XSD pour le block courant.
     * @param DOMDocument $xsd
     * @return type
     */
    public function generateXSDElement(DOMDocument $xsd){
        $element = $xsd->createElement("xs:element");
        $element->setAttribute('name', $this->getName());
        
        $type = $xsd->createElement("xs:complexType");
        
        $sequence = $xsd->createElement("xs:sequence");
        
        $sequence->setAttribute('minOccurs', 0);
        $sequence->setAttribute('maxOccurs', 1);
        
        $type->appendChild($sequence);
        
        $element->appendChild($type);
        
        return $element;
    }

    /**
     * @param EiDataSet|EiTestSet $object
     * @param DOMDocument $document
     * @param DOMElement $parent
     * @return string
     */
    public function generateMappingDataSetXML($object, DOMDocument &$document = null, DOMElement $parent = null, $index = null)
    {
        $chrono = new Chronometre();

        $titre = "Génération des paramètres";
        $chrono->lancerChrono($titre);
        /** @var EiBlockParam[] $parametres */
        $parametres = $this->getParams();
        $chrono->arreterEtAfficherChrono();

        // Création du document.
        if( $document === null ){
            $document = new DOMDocument("1.0", "UTF-8");
            $document->formatOutput = true;
        }

        if( $parent === null ){
            $blockElt = $document->createElement("Root");
            $document->appendChild($blockElt);
        }
        else{
            $blockElt = $document->createElement($this->getName());
            $parent->appendChild($blockElt);
        }

        foreach( $parametres as $param ){

            /** @var EiBlockDataSetMapping $mapping */
            $mapping = $param->getMapping(EiBlockDataSetMapping::$TYPE_IN);
            $value = "";

            if( $mapping != null && $object instanceof EiTestSet )
            {
                $value = $mapping->getValueFromTestSetJdd($object, $index);
            }
            elseif( $mapping != null && $object instanceof EiDataSet ){
                $value = $mapping->getValueFromJdd($object, $index);
            }

            /** @var DOMElement $element */
            $element = $document->createElement($param->getName(), $value);

            $blockElt->appendChild($element);
        }

        /** @var EiVersionStructure[] $descendants */
        $descendants = $this->getNode()->getDescendants();

        if( $descendants ){
            /** @var EiVersionStructure $descendant */
            foreach($descendants as $descendant){
                /** @var EiBlock $descendant */
                if( $descendant instanceof EiBlock || $descendant instanceof EiBlockForeach ){
                    $descendant->generateMappingDataSetXML($object, $document, $blockElt);
                }
            }
        }

        return $document->saveXML();
    }

    /**
     * @param EiTestSet $testSet
     * @param null $parent
     * @param null $index
     * @param string $path
     * @param bool $deep
     * @param Doctrine_Connection $conn
     *
     * @return EiTestSetBlockParam|mixed|void
     */
    public function generateTestSetParameters(EiTestSet $testSet = null, $parent = null, $index = null, $path = "", $deep = true, Doctrine_Connection $conn = null)
    {
        $conn = $conn == null ? Doctrine_Manager::connection():$conn;
        $chronometre = new Chronometre();

        $index = $index == null ? 1 : $index;
        $path.= "/" . $this->getName() . "[".$index."]";

        // Vérification si l'élément existe.
        $element = EiTestSetBlockParamTable::getInstance()->findOneByEiTestSetIdAndPath($testSet->getId(), $path);

        if( $element == null ){
            // Création de l'élément.
            $element = new EiTestSetBlockParam();

            $element->setEiVersionStructureId($this->getId());
            $element->setName($this->getName());
            $element->setSlug($this->getSlug());
            $element->setType($this->getType());
            $element->setEiTestSetId($testSet->getId());
            $element->setIndexRepetition($index);
            $element->setPath($path);

            if( $parent != null ) $element->setParentId($parent->getId());

            $element->save($conn);

            if( $parent == null ){
                $element->setRootId($element->getId());
                $element->setLft(1);
                $element->setRgt(2);
                $element->setLevel(0);

                $element->save($conn);
            }
            elseif( $parent != null ){
                /** @var EiTestSetBlockParam $parent */
                $parent->refresh(true);

                if( !$parent->getNode()->getChildren() ){
                    $element->getNode()->insertAsFirstChildOf($parent);
                }
                else{
                    $element->getNode()->insertAsNextSiblingOf($parent->getNode()->getLastChild());
                }
            }
        }


        $chronometre->lancerChrono("Récupération des paramètres");
        /** @var EiBlockParam[] $parametres */
        $parametres = $this->getParams();
        $chronometre->arreterEtAfficherChrono();

        $chronometre->lancerChrono("Génération des paramètres");
        /** @var EiBlockParam $param */
        foreach( $parametres as $param ){
            $param->generateTestSetParameters($testSet, $element, $index, $path);
        }
        $chronometre->arreterEtAfficherChrono();

        /** @var EiVersionStructure[] $descendants */
        $descendants = $this->getNode()->getDescendants(true);

        if( $deep === true && $descendants ){
            /** @var EiVersionStructure $descendant */
            foreach($descendants as $descendant){
                /** @var EiBlock $descendant */
                if( $descendant instanceof EiBlock || $descendant instanceof EiBlockForeach ){
                    $descendant->generateTestSetParameters($testSet, $element, $index, $path, false, $conn);
                }
            }
        }
        else{
            return $element;
        }
    }

    /**
     * Retourne, sous forme de chaine de caractère HTML, le chemin jusqu'au 
     * block.
     * @return string
     */
    public function getPathTo() {
        $res = "";
        if ($this->getNode()->hasParent())
            foreach ($this->getNode()->getAncestors() as $ei_block)
                $res .= "<li>" . $ei_block->getName() . '<span class="divider">/</span> </li>';

        $res .= "<li> <strong>" . $this->getName() . '</strong><span class="divider">/</span> </li>';

        return $res;
    }

    /**
     * @return string
     */
    public function getPathToString(){
        return str_replace(" ", "", "/".strip_tags($this->getPathTo()));
    }

    /**
     * Formatte les paramètres pour les utiliser dans l'édition de la version.
     * @param type $params
     * @return type
     */
    public function getJSONParameters($params) {
        $parameters = array();
     
        foreach($params as $i => $p) {
            $repeat =  $this->getLevel() - $p->getLevel() + 1;

            $parameters[$i]['val']=  "{".str_repeat('../', $repeat) . $p->getName()."}";
            $nodeParent=$p->getNode()->getParent();
            if($nodeParent!=null):
                $parameters[$i]['meta'] = $nodeParent->getName() . ': ' . $p->getName();
            endif;
            
        }

        return json_encode($parameters);
    }

    public function createLiElem($url_tab,$block_redirect_class, $active = false) {

        $eiblock_edit_uri=$url_tab;
        $eiblock_edit_uri['ei_block_root_id']=$this->id;  
        $eiblock_edit_uri['action'] = 'edit';
        
        if($active){
            $active = "current_block active";
            $arrow = '<i class="icon-chevron-right"></i>';
            
        }
        else {
            $active = "";
            $arrow = "";
        }

        if($this->getNode()->isRoot()){
            $imgs = "";
            $padding = "padding-left";
        }
        else {
            $padding = '';
            $imgs = '    
           <img class="open_block" title="Open" alt="" src="/images/icones/fleche-droite.png">
           <img class="close_block " title="Close" alt="" src="/images/icones/fleche-bas.png">';
        }

        $return = sprintf('<li ei_block="%d" class="%s">
           
           <div class="'. $active . ' '.$padding.'">'.
           $imgs

           .'<i class="icon-inbox"></i>%s '. $arrow .' </div>', $this->id, "sortable", link_to2($this->name, 'projet_edit_eiversion',$eiblock_edit_uri, array(
               'itemref' => url_for2("projet_edit_eiversion" ,$eiblock_edit_uri),
               'class' => "go_to_block_$block_redirect_class ",
               'title' => "Open " . $this->name . " panel")));

        return $return;
    }

    public function save(Doctrine_Connection $conn = null)
    {
        $this->setSlug(MyFunction::sluggifyForXML($this->getName()));

        parent::save($conn); // TODO: Change the autogenerated stub
    }

}
