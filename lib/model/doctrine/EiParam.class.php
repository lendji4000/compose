<?php

/**
 * EiParam
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    kalifast
 * @subpackage model
 * @author     Your name here
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class EiParam extends BaseEiParam
{
    
    private $name;
    private $defaultValue;
    private $description;
    
     public function getKalParam(){
        return Doctrine_Core::getTable('EiFunctionHasParam')->findOneByParamId($this->getParamId());
    }

    public function createCopie($id_fonction=null,$conn=null){
        
        
        try {

            //Création de la copie
            $copie = new EiParam();
            if ($id_fonction != null) 
                $copie->setIdFonction($id_fonction);
            else 
                $copie->setIdFonction($this->getIdFonction());
            
            $copie->setParamId($this->getParamId());
            $copie->setValeur($this->getValeur());
            $copie->setObservation($this->getObservation());
                
            //Sauvegarde de la copie
            $copie->save($conn);
            
        } catch (Exception $e) {
            throw $e;
        }
    }
    
    /**
     * Retourne la forme parsée d'un paramètre pour l'interprétation par le XSL
     * 
     * @author Grégory Elhaimer
     * @return String
     */
    public function getParsedForm(){
        // regex recherchant tous les paramètres qui sont précédé d'un nombre pair de # 
        //(soit un nombre impair de # avant l'accolade ouvrante). 
        //                        |--1--||------2-----|
        $patternImpair = "#(?<!\#)(\#\#)*(\#\{[\w./]*})#";
        $nbMatchedImpair = preg_match_all($patternImpair, $this->getValeur(), $matches);
        //$matches[0] contient les résultats complets.
        //$matches[1] contient la série de # précédant le paramètre pour l'expression matchée
        //$matches[2] contient le paramètre à proprement parler (la forme #{})
        
        if(isset($matches) && $nbMatchedImpair > 0){
            $toReplace = array();
            // pour chaque élément qui a matché le pattern
            foreach($matches[0] as $m => $param){
                //on protège notre expression afin que celle-ci ne soit pas considérer comme un pattern de regex
                $matches[0][$m] = '#'.preg_quote($param, '#').'#';
                //puis l'on créer la chaine de remplacement correspondante
                $toReplace[$m] = $matches[1][$m].'<xsl:value-of select="'.  substr($matches[2][$m], 2, -1).'"/>';   
            }
            //on replace pour chaque $matches par la nouvelles chaine générée puis stockées dans $toReplace
            //dans la chaine représentant la valeur de notre EiParam
            $res = preg_replace($matches[0], $toReplace, $this->getValeur());
        }
        //si aucune valeur n'a été trouvée, alors on retournera simplement la valeur du paramètre.
        else 
            $res = $this->getValeur();
        
        //on transforme ## en #.
        return preg_replace("#\#\##", "#", $res);
    }
    
    
    public function generateXSLForTestSet(DOMDocument $xsl, DOMNode $parentNode, $isInRoot = false){
        // regex recherchant tous les paramètres qui sont précédé d'un nombre pair de # 
        //(soit un nombre impair de # avant l'accolade ouvrante). 
        //                        |--1--||------2-----|
        $patternImpair = "#(?<!\#)(\#\#)*(\#\{[\w./]*})#";
        $nbMatchedImpair = preg_match_all($patternImpair, $this->getValeur(), $matches);
        //$matches[0] contient les résultats complets.
        //$matches[1] contient la série de # précédant le paramètre pour l'expression matchée
        //$matches[2] contient le paramètre à proprement parler (la forme #{})

        $paramNode = $xsl->createElement($this->getKalParam()->getName());
        $paramNode->setAttribute('param_id', $this->getParamId());

        $value = $this->getValeur();

        if(isset($matches) && $nbMatchedImpair > 0){
            $toReplace = array();
            // pour chaque élément qui a matché le pattern
            foreach($matches[0] as $m => $param){
                //on protège notre expression afin que celle-ci ne soit pas considérer comme un pattern de regex
                $matches[0][$m] = '#'.preg_quote($param, '#').'#';
                //puis l'on créer la chaine de remplacement correspondante

                $dompar = $xsl->createElement("xsl:value-of");
                $select = substr($matches[2][$m], 2, -1);

                if($isInRoot)
                    $select = "//".$select;

                $dompar->setAttribute("select", $select);

                $sous_chaine_restante=  strstr($value, $param);
                $paramNode->appendChild($xsl->createCDATASection(preg_replace("#\#\##", "#",
                        substr($value,0, stripos($value,$sous_chaine_restante)).$matches[1][$m]
                        )));
                $paramNode->appendChild($dompar);
                //On extrait à la sous chaine restante le paramètre variable trouvé
                $value=substr($sous_chaine_restante,strlen($param));
            }

            //on ajoute le reste de la chaine

        }

        $paramNode->appendChild(
                $xsl->createCDATASection( preg_replace("#\#\##", "#", $value
                        )));

        $parentNode->appendChild($paramNode);
    }
    
    public function getName(){
        return strlen($this->name) > 0 ? $this->name:$this->getEiFunctionHasParam()->getName();
    }
   
    public function setName($nom){
        $this->name = $nom;
    }
    
    public function  getDescription(){
        return strlen($this->description) > 0 ? $this->description:$this->getEiFunctionHasParam()->getDescription();
    }
    
    public static  function truncateDesc($description,$size = 25){
        if($size <= 0)
            throw new InvalidArgumentException('Invalid size value to troncate. '. $size . ' is not a valid value.');
        
        if (strlen($description) > $size):
            return substr($description, 0, $size-3) . '...';
        else:
            return $description;
        endif;
    }
   
    public function setDescription($nom){
        $this->description = $nom;
    }
    
    public function getDefaultValue(){
        return $this->defaultValue;
    }
    
    public function setDefaultValue($value){
        $this->defaultValue = $value;
    }
    
}
