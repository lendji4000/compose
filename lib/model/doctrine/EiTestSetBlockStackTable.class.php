<?php

/**
 * EiTestSetBlockStackTable
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class EiTestSetBlockStackTable extends Doctrine_Table
{
    /**
     * Returns an instance of this class.
     *
     * @return object EiTestSetBlockStackTable
     */
    public static function getInstance()
    {
        return Doctrine_Core::getTable('EiTestSetBlockStack');
    }

    /**
     * @param EiTestSetBlockStack $stack
     */
    public function getAllTestSetBlockParamParentsId(EiTestSetBlockStack $stack){

    }

    /**
     * TODO: A vérifier
     * ADD block to stack.
     *
     * @param EiTestSet $testSet
     * @param EiVersionStructure $block
     * @param EiTestSetBlockStack $previousStack
     * @param EiTestSetBlockStack $parentStack
     * @param int $position
     * @param Doctrine_Connection $conn
     * @return EiTestSetBlockStack
     */
    public function addToStack(EiTestSet $testSet, EiVersionStructure $block, EiTestSetBlockStack $previousStack = null, EiTestSetBlockStack $parentStack = null, $position = 1, Doctrine_Connection $conn = null){
        $conn = $conn == null ? Doctrine_Manager::connection():$conn;
        $parStrId = $parentStack != null ? $parentStack->getEiVersionStructureId():"";
        $prevStrId = $previousStack != null ? $previousStack->getEiVersionStructureId():"";
        $strId = $block->getId();
        $dataSetStr = null;

//        var_dump($block->toArray(false));exit;

        // On définit l'index du précédent ainsi que sa fragmentation
        if( $previousStack != null ){
            $prevIndex = $previousStack->getRepetitionIndex();
            $prevPartsCount = $previousStack->getPartsCount();
            $prevPartsIndex = $previousStack->getPartIndex();
        }
        else{
            $prevIndex = $prevPartsCount = $prevPartsIndex = 0;
        }

        // On définit l'index du père ainsi que sa fragmentation
        if( $parentStack != null ){
            $parIndex = $parentStack->getRepetitionIndex();
            $parPartsCount = $parentStack->getPartsCount();
            $parPartsIndex = $parentStack->getPartIndex();
        }
        else{
            $parIndex = $parPartsCount = $parPartsIndex = 0;
        }

        //***********************************************************//
        //**********     GESTION ASSOCIATION STACK/JDD     **********//
        //***********************************************************//

        if( $parentStack != null ){
            $dataSetStr = $this->getDataFromDataSet($testSet, $block, $previousStack, $parentStack);
        }
        else{
            $dataSetStr = $this->getDataFromDataSet($testSet, $block);
        }

        //*********************************************************//
        //**********     AJOUT ELEMENT DANS LA STACK     **********//
        //*********************************************************//

        // On crée le nouvel élément de la pile.
        $stack = new EiTestSetBlockStack();
        $stack->setEiTestSet($testSet);
        $stack->setEiVersionStructure($block);
        $stack->setEiTestSetDataSet($dataSetStr);
        $stack->setPosition($position);

        if( $parentStack != null && $parentStack->getEiVersionStructure()->isEiLoop() && $block->getId() == $parStrId ){
            $stack->setEiTestSetBlockStackParent($parentStack->getEiTestSetBlockStackParent());
        }
        else{
            $stack->setEiTestSetBlockStackParent($parentStack);
        }

        // Vérification de la fragmentation du block.
        $stack->setPartsCount($this->getFragmentsCount($stack));

//        var_dump($strId . " VS " . $parStrId);
//        var_dump($parPartsIndex . " VS " . $parPartsCount);

        // Récupération de l'index.
        // Cas où il y a un précédent de même type que le suivant et que le précédent est terminé.
        if( $previousStack != null && $strId == $prevStrId && !($prevPartsIndex < $prevPartsCount) ){
//            var_dump("CAS INDEX PART 1");
            // On incrémente alors son index car cela signifie que l'on passe à la boucle suivante.
            $stack->setRepetitionIndex($prevIndex+1);
        }
        // Cas où il y a un précédent de même type que le suivant et que le précédent n'est pas terminé.
        elseif( $previousStack != null && $strId == $prevStrId && $prevPartsIndex < $prevPartsCount ){
//            var_dump("CAS INDEX PART 2");
            // On n'incrémente pas l'index car cela signifie que nous sommes dans la même boucle.
            $stack->setRepetitionIndex($prevIndex);
            // Et on incrémente la partie.
            $stack->setPartIndex($prevPartsIndex+1);
        }
        // Cas où le père est du même type que le suivant et que le père a terminé son exécution
        elseif( $parentStack != null && $strId == $parStrId && !($parPartsIndex < $parPartsCount) ){
//            var_dump("CAS INDEX PART 3");
            $stack->setRepetitionIndex($parIndex+1);
        }
        // Cas où le père est du même type que le suivant et que le père n'a pas terminé son exécution
        elseif( $parentStack != null && $strId == $parStrId && $parPartsIndex < $parPartsCount ){
//            var_dump("CAS INDEX PART 4");
            $stack->setRepetitionIndex($parIndex);
            $stack->setPartIndex($parPartsIndex+1);
        }
        else{
//            var_dump("CAS INDEX PART 5");
        }

        $stack->save($conn);

        return $stack;
    }

    /**
     * Méthode permettant de localiser la partie du JDD à lier à l'élément du block.
     *
     * TODO: Unifier les deux méthodes en une seule.
     * TODO: A vérifier
     *
     * Liée à EiTestSetBlockStack->getDataFromDataSet
     *
     * @param EiTestSet $testSet
     * @param EiVersionStructure $block
     * @param EiTestSetBlockStack $previousStack
     * @param EiTestSetBlockStack $parentStack
     * @return mixed|null
     */
    public function getDataFromDataSet(EiTestSet $testSet, EiVersionStructure $block, EiTestSetBlockStack $previousStack = null, EiTestSetBlockStack $parentStack = null){
        /** @var EiTestSetDataSetTable $tableDSS */
        $tableDSS = Doctrine_Core::getTable("EiTestSetDataSet");
        $mapping = $block->getMappingDataSet(EiBlockDataSetMapping::$TYPE_IN);
        $dssStr = null;

        // Cas où il y a un mapping et que le parent est nul : On prend le premier élément que l'on trouve.
        if( $parentStack == null && $mapping != null ){
            $dssStr != null ? $tableDSS->getRelatedDataFromUniqueDataSetStructure($testSet->getId(), $mapping):null;
        }
        // Sinon, si un mapping existe.
        elseif( $mapping != null ){
            // On vérifie que le block en question est une boucle.
            if( $block->isEiLoop() )
            {
                // On récupère le contexte du père.
                $contexte = $parentStack->getContext();
                $index = 1;

//                var_dump("DataSet Père : " . $parentStack->getEiTestSetDatasetId());
//                var_dump("Contexte DataSet Père : " . $contexte);

                // Si le block courant est de même nature que le block précédent
                if( $parentStack->getEiVersionStructureId() != $block->getId() && $block->getId() == $previousStack->getEiVersionStructureId() ){
//                    var_dump("DataSet Structure CAS 1");
                    // On vérifie s'il s'agit de la même boucle mais concerne une partie différente.
                    if( $previousStack->getPartIndex() < $previousStack->getPartsCount() ){
                        $index = $previousStack->getRepetitionIndex();
                        $contexte.= "-" . $index;
                    }
                    // Ou s'il s'agit de l'incrémentation suivante.
                    else{
                        $index = $previousStack->getRepetitionIndex() + 1;
                        $contexte.= "-" . $index;
                    }
                }
                // Sinon, si les blocks parent & précédent n'ont pas de lien avec le block suivant...
                elseif( $parentStack->getEiVersionStructureId() != $block->getId() ){
//                    var_dump("DataSet Structure CAS 2");
                    $parentStr = $parentStack->getEiTestSetDataSet() != null ? $parentStack->getEiTestSetDataSet()->getEiDataSetStructure():null;

                    if( $parentStr != null && $mapping->getEiDataSetStructureMapping()->getNode()->isDescendantOf($parentStr) ){
//                        var_dump("DataSet Structure CAS 2.1");
                        $parentMapping = $parentStr != null ? $parentStr->getId():null;
                        $myMappingParent = $mapping->getEiDataSetStructureMapping()->getEiDatasetStructureParentId();

                        if( $parentMapping == null || $myMappingParent == $parentMapping ){
                            $contexte.= "-1";
                        }
                        else{

                            if( preg_match("/([0-9]+)$/", $contexte, $matched) ){
                                $length = strlen($matched[1]);
                            }
                            else{
                                $length = 1;
                            }

                            $contexte = substr($contexte, 0, -$length) . 1;
                        }
                    }
                    else{
//                        var_dump("DataSet Structure CAS 2.2");

                        $contexteArray = array();

                        for( $cpt = 0; $cpt <= $mapping->getEiDataSetStructureMapping()->getLevel(); $cpt++ ){
                            $contexteArray[] = 1;
                        }

                        $contexte = implode("-", $contexteArray);

//                        var_dump("New context : " . $contexte);
                    }
                }
                // Le block parent est le même que le suivant.
                else{
//                    var_dump("DataSet Structure CAS 3");

                    if( preg_match("/([0-9]+)$/", $contexte, $matched) ){
                        $length = strlen($matched[1]);
                    }
                    else{
                        $length = 1;
                    }

                    $contexte = substr($contexte, 0, -$length);

                    // On vérifie s'il s'agit de la même boucle mais concerne une partie différente.
                    if( !$parentStack->isComplete() ){
                        $index = $parentStack->getRepetitionIndex();
                    }
                    // Ou s'il s'agit de l'incrémentation suivante.
                    else{
                        $index = $parentStack->getRepetitionIndex() + 1;
                    }

                    $contexte.= $index;

//                    var_dump($parentStack->getEiVersionStructureId(), $block->getId());
//                    var_dump($contexte);
                }

                $dssStr = $tableDSS->getDataFromContext($testSet->getId(), $mapping->getEiDatasetStructureId(), $contexte, $index);
            }
        }

        return $dssStr;
    }

    /**
     * @param EiTestSetBlockStack $stack
     * @return bool
     */
    public function elementExists(EiTestSetBlockStack $stack){
        $query = $this->createQuery("q")
            ->andWhere("q.ei_test_set_id = ?", $stack->getEiTestSetId())
            ->andWhere("q.path = ?", $stack->getPath())
            ->andWhere("q.part_index = ?", $stack->getPartIndex())
            ->andWhere("q.executed = ?", true)
        ;

        return $query->execute()->count() > 0;
    }

    /**
     * @param null $testSetId
     * @param Doctrine_Connection $conn
     */
    public function validateStackElements($testSetId = null, Doctrine_Connection $conn = null){
        $conn = $conn == null ? Doctrine_Manager::connection():$conn;

        $sql = "UPDATE ei_test_set_block_stack SET executed = 1 WHERE ei_test_set_id = " . $testSetId;

        $conn->execute($sql);
    }

    /**
     * @param $testSetId
     * @param $rootId
     * @return EiTestSetBlockStack
     */
    public function getLastRootStack($testSetId, $rootId){
        $query = $this->createQuery("q")
            ->andWhere("q.ei_test_set_id = ?", $testSetId)
            ->andWhere("q.ei_version_structure_id = ?", $rootId)
            ->orderBy("q.position DESC")
        ;

        return $query->execute()->getFirst();
    }

    /**
     * @param $testSetId
     * @param $path
     * @return EiTestSetBlockStack
     */
    public function getLastElementFromPath($testSetId, $path){
        $query = $this->createQuery("q")
            ->andWhere("q.ei_test_set_id = ?", $testSetId)
            ->andWhere("q.path = ?", $path)
            ->orderBy("q.position DESC")
        ;

        return $query->execute()->getFirst();
    }

    /**
     * TODO: Adapater à tous les types de boucles : while, for.
     *
     * Méthode permettant d'identifier la taille de la boucle.
     *
     * @param EiTestSetBlockStack $stack
     */
    public function getLoopSize(EiTestSetBlockStack $stack = null){
        $count = 0;
        $structure = $stack->getEiTestSetDataSet();

        if( $structure != null && $structure->getId() != "" && $structure->getId() != null ){
            /** @var EiTestSetDataSet $parentDs */
            $parentDs = $structure->getNode()->getParent();

            /** @var EiTestSetDataSetTable $tsDSTable */
            $tsDSTable = Doctrine_Core::getTable("EiTestSetDataSet");

            $count = $tsDSTable->getSameElementsCount($stack->getEiTestSetId(), $structure->getEiDataSetStructureId(), $parentDs->getLft(), $parentDs->getRgt());
        }

        return $count;
    }

    /**
     * Méthode permettant de récupérer le nombre de fragments d'un block. C'est à dire en combien de parties
     * est divisé le block. Par exemple, si mon block comporte 3 fonctions avec un block entre la 2ème et la 3ème fonction
     * alors mon block est divisé en 2 parties.
     *
     * @param EiTestSetBlockStack $stack
     * @return int
     */
    public function getFragmentsCount(EiTestSetBlockStack $stack = null){
        $count = 0;
        $last = "";

        $res = $this->getNextVersionStructureFragmentsObjects($stack);

//        var_dump("Nombre de résultats : " . count($res));

        if( !is_bool($res) ){
            foreach( $res as $elt ){
//                var_dump($elt["type"]);
                if( $elt["type"] == EiVersionStructure::$TYPE_FONCTION && $last != EiVersionStructure::$TYPE_FONCTION ){
                    $count++;
                }
                elseif( in_array($elt["type"], EiVersionStructure::getBlockTypes()) ){
                    $count++;
                }

                $last = $elt["type"];
            }
        }

//        var_dump($count);exit;

        return $count;
    }

    /**
     * @param EiTestSetBlockStack $stack
     * @return array
     */
    private function getNextVersionStructureFragmentsObjects(EiTestSetBlockStack $stack = null){
        /** @var EiVersionStructure $structure */
        $structure = $stack->getEiVersionStructure();

        $sql = "
        SELECT *
FROM ei_version_structure  vs
WHERE ei_version_id = ".$structure->getEiVersionId()."
AND lft >= ".$structure->getLft()." AND rgt <= ".$structure->getRgt()."
AND type NOT IN ('".EiVersionStructure::$TYPE_BLOCK_PARAM."')
AND level = ".($structure->getNode()->getLevel() + 1)."
ORDER BY lft;";

        return Doctrine_Manager::connection()->execute($sql)->fetchAll();
    }

    /**
     * Méthode permettant de récupérer la subdivision du block.
     *
     * @param EiTestSetBlockStack $stack
     */
    public function getNextVersionStructureFragments(EiTestSetBlockStack $stack = null){
        $list = array();
        $index = 0;
        $last = "";
        $pIndex = $stack->getPartIndex();

        $res = $this->getNextVersionStructureFragmentsObjects($stack);

//        var_dump("Next Functions ?");
//        var_dump($stack->getPartIndex() . "/" . $stack->getPartsCount());

        if( !is_bool($res) ){
            foreach( $res as $elt ){
//                var_dump("Index : " . $index);
//                var_dump($elt["type"] . " / " . $last);

                if( $elt["type"] == EiVersionStructure::$TYPE_FONCTION && $last != EiVersionStructure::$TYPE_FONCTION ){
//                    var_dump("CAS 1");
                    $index++;
                }
                elseif( in_array($elt["type"], EiVersionStructure::getBlockTypes()) ){
//                    var_dump("CAS 2");
                    $index++;
                }

                if( $pIndex == $index && $elt["type"] == EiVersionStructure::$TYPE_FONCTION ){
                    $list[] = $elt["id"];
                }

                $last = $elt["type"];
            }
        }

        return $list;
    }

    /**
     * Méthode permettant de récupérer le block, faisant partie de la subdivision du parent, à exécuter.
     *
     * @param EiTestSetBlockStack $stack
     * @param null $pIndex
     * @return EiVersionStructure
     */
    public function getNextBlockFragments(EiTestSetBlockStack $stack = null, $pIndex = null){
        $index = 0;
        $last = "";
        $block = null;
        $pIndex = $pIndex == null ? $stack->getPartIndex() + 1:$pIndex;

        $res = $this->getNextVersionStructureFragmentsObjects($stack);

//        var_dump("Is Block ?");
//        var_dump($pIndex . "/" . $stack->getPartsCount());

        if( !is_bool($res) ){
            foreach( $res as $elt ){
//                var_dump("Index : " . $index);
//                var_dump($elt["type"] . " / " . $last);

                if( $elt["type"] == EiVersionStructure::$TYPE_FONCTION && $last != EiVersionStructure::$TYPE_FONCTION ){
//                    var_dump("CAS 1");
                    $index++;
                }
                elseif( in_array($elt["type"], EiVersionStructure::getBlockTypes()) ){
//                    var_dump("CAS 2");
                    $index++;
                }

//                var_dump("Index Before CMP : " . $index);

                if( $pIndex == $index && in_array($elt["type"], EiVersionStructure::getBlockTypes()) ){
//                    var_dump("OK found");
                    $block = Doctrine_Core::getTable("EiVersionStructure")->find($elt["id"]);
                }

                $last = $elt["type"];
            }
        }

        return $block;
    }

    /**
     * Méthode permettant de savoir si la sous-partie du block commence par un block ou non.
     *
     * @param EiTestSetBlockStack $stack
     * @param null $pIndex
     * @return bool
     */
    public function firstFragmentElementIsFunction(EiTestSetBlockStack $stack = null, $pIndex = null){
        $last = "";
        $index = 1;
        $pIndex = $pIndex == null ? $stack->getPartIndex():$pIndex;

        $res = $this->getNextVersionStructureFragmentsObjects($stack);

//        var_dump("Is Function ? ");
//        var_dump($pIndex . "/" . $stack->getPartsCount());

        if( !is_bool($res) ){
            foreach( $res as $elt ){
//                var_dump("Index : " . $index);
//                var_dump($elt["type"] . " / " . $last);

                if( $pIndex == $index && !($elt["type"] == EiVersionStructure::$TYPE_FONCTION && $last == EiVersionStructure::$TYPE_FONCTION) ){
//                    var_dump("CAS 1 : " . ($elt["type"] == EiVersionStructure::$TYPE_FONCTION ? 1:0));
                    return $elt["type"] == EiVersionStructure::$TYPE_FONCTION;
                }

                if( in_array($elt["type"], EiVersionStructure::getBlockTypes()) ){
//                    var_dump("CAS 2");
                    $index++;
                }
                elseif( $elt["type"] == EiVersionStructure::$TYPE_FONCTION && $last != EiVersionStructure::$TYPE_FONCTION ){
//                    var_dump("CAS 3");
                    $index++;
                }

                $last = $elt["type"];
            }
        }

//        exit;

        return false;
    }

    /**
     * @param EiTestSetBlockStack $stack
     * @param EiTestSetBlockStack $previousStack
     * @return bool
     */
    public function isPreviousStackCurrentFragment(EiTestSetBlockStack $stack, EiTestSetBlockStack $previousStack = null){
        $res = false;

        if( $previousStack != null ){
            $nextBlock = $this->getNextBlockFragments($stack, $stack->getPartIndex());
            $parentBlock = $previousStack->getEiVersionStructure();

            if( $nextBlock != null ){
//                var_dump("PARENT VS ID : " . $parentBlock->getId());
//                var_dump("CURRENT FRAGMENT VS ID : " . $nextBlock->getId());

                $res = $nextBlock != null && $parentBlock->getId() == $nextBlock->getId();
            }
        }

        return $res;
    }

    /**
     * @param EiTestSetBlockStack $stack
     * @return bool
     */
    public function nextFragmentElementIsFunction(EiTestSetBlockStack $stack = null){
        return $this->firstFragmentElementIsFunction($stack, $stack->getPartIndex() + 1);
    }
}